% This is based on the LLNCS.DEM the demonstration file of % the LaTeX macro
% package from Springer-Verlag % for Lecture Notes in Computer Science, version
% 2.4 for LaTeX2e as of 16. April 2010
%
% See http://www.springer.com/computer/lncs/lncs+authors?SGWID=0-40209-0-0-0
% for the full guidelines.
\documentclass{llncs}
\usepackage{graphicx}
\graphicspath{ {./assets/} }

\usepackage{enumitem}
\setlist[enumerate]{itemsep=2mm}

\usepackage{dirtytalk}
\usepackage{minted}
%\usepackage{amsmath}
%\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{extarrows}
\usepackage{pdflscape}
\usepackage[pass]{geometry}

%
% Tables
% --------
\usepackage[table]{xcolor}
\usepackage{hhline}
\usepackage{booktabs} % much better tables
\usepackage{multirow} % allows to fuse rows
\usepackage{array}    % manipulate array
\usepackage{tabularx} % better tables

% Define new tabularx column types:
%  - R: streteched right aligned
%  - C: stretched centered
%  - N: left aligned, specified space
\newcolumntype{R}{>{\raggedleft\arraybackslash}X}
\newcolumntype{C}{>{\centering\arraybackslash}X}
\newcolumntype{N}[1]{>{\raggedleft\arraybackslash}p{#1}}
\newcolumntype{S}{>{\hsize=.5\hsize}C}

% Set row height multiplicator to provide more breathing space
\renewcommand{\arraystretch}{1.5}

\usepackage[backend=biber]{biblatex}
\addbibresource{bibliography.bib}

\pagestyle{plain}
\setcounter{page}{1}
\pagenumbering{arabic}

%\usepackage{pgfplots}
%\pgfplotsset{width=6cm}
\usepackage{float}
\usepackage[caption = false]{subfig}

\begin{document}

\title{Bitcoin--Monero Cross-chain Atomic Swap}
\author{h4sh3d\inst{1}}

\authorrunning{h4sh3d et al.}
\tocauthor{h4sh3d}
\subtitle{{\normalsize\today{\small\ -- DRAFT}}}
\institute{TrueLevel\\ \email{h4sh3d@truelevel.io}}

\maketitle

\begin{abstract}
    Cross-chain atomic swaps have been discussed for a very long time and are very useful tools. This protocol describes how to achieve atomic swaps between Bitcoin and Monero with two transactions per chain without trusting any central authority, servers, nor the other swap participant. We propose a swap between two parties, one holding bitcoins and the other monero.
    \keywords{Bitcoin, Monero, Cross-chain swaps}
\end{abstract}

\section{Introduction}
We describe a protocol for an on-chain atomic swap between Monero and Bitcoin, but the protocol can be generalize to Monero and any other cryptocurrencies that fulfill the same requirements as Bitcoin.

This protocol is heavily based on a Monero StackExchange post discussing if it's possible to trade Monero and Bitcoin in a trustless manner \cite{MoneroStackexchangeSwap}. The concept is roughly the same, with some changes in the Bitcoin part and is explained in more detail; they send funds to a special location on each chain (cross-chain) where each party can take control of the other chain (swap) and the other chain only (atomic).

\subsection{Known limitations}
To provide finality (if at least one participant is still online) we allow the worst case scenario to end up with one participant loosing his funds, but this case should only happen with negligible probability. Rationale behind this design is explained in \ref{worstCaseRationale}.

Fees are different from one chain to the other because of internal blockchain parameters and transaction complexity. Because the Bitcoin blockchain is used as a decision engine transactions are, related to Bitcoin transactions, complexe and then expensive. Thus making the Bitcoin chain expensier than the Monero chain.

Speed in cross-chain atomic swap is hard to achieve, the slowest chain and the number of confirmations dictate the speed of the protocol, making front runs possible in some cases.

\section{Scenario}
We describe the participants and their incentives. Alice, who owns Monero (XMR), and Bob, who owns Bitcoin (BTC), want to swap funds. We assume that they already have negotiated the amounts of bitcoins and monero to swap in advance. This negotiation can also be integrated into the protocol for example swap services who provide a price to their customers.

Both want only to issue when executing the protocol: (1) the protocol succeed and Alice gets bitcoins, Bob gets monero, or (2) the protocol fails and both want to keep their original funds minus the minimum transactions' fees.

\subsection{Successful swap}
If both participants follow the protocol 4 transactions in total will be broadcast, 2 on Bitcoin blockchain and 2 on Monero blockchain. The first ones locks the funds and makes them ready for the trade on each chain. The second ones unlocks the funds for one participant only and gives knowledge to the other participant who takes control of the output on the other chain.

In that case the protocol is the fastest, only locking funds requires confirmations on each chain depending on the level of security wanted by each participant and no timelocks are waited to follow the protocol.

\subsection{Swap correctly aborted}
When locking the bitcoins, after a timelock Alice or Bob can start the process of refunding the locked funds. In this case the monero might not be locked yet, if no monero are locked the refund process will just refund the bitcoins, otherwise Alice will learn enough information to refund her monero too.

When the refund transaction is broadcast Bob has to spend the refund before some timelock, otherwise he might end up loosing his bitcoins without getting any monero.

\subsection{Worst case scenario}
If the swap is cancelled with the refund process and Bob does not spend his funds before the timelock, Alice can claim the refund. Thus one participant, Bob, end up underwater and 3 Bitcoin transactions are needed instead of 2.

\subsubsection{Rationale}
\label{worstCaseRationale}
This choice is made to avoid the following case: if monero are locked, Alice will be able to refund them only if Bob refund his bitcoins first, we need an incentive mechanisme to force Bob to spend his refund.

\section{Prerequisites}
As we described it before, conditional execution must be possible in order to achieve a swap and atomicity. Bitcoin has a small stack-based script language that allows conditional execution and timelocks. On the other hand Monero with its privacy oriented RingCT design provides only signatures to unlock UTXOs. Meaning that control of UTXOs is only related to who controls the associated private keys. The challenge is then to move control of funds only with knowledge of some private keys.

Requirements for activated features for each chain are a bit different that the StackExchange post. We describe all components needed on and off-chain.

\subsection{Monero}
Monero does not require any particular primitives on-chain (hashlocks, timelocks), all building blocks are off-chain primitives. Thus we need to provide proofs of the correct following of the protocol initialization, and this might be the hardest part.

\subsubsection{Shared secret,}
to enable a basic two-path execution in Monero. The Monero swap private spend key is split into 2 shared secrets $x_0, x_1$. Participants will not use any multi-signing protocol, instead, the private spend key shares are distributed during initialization of the swap process and one participant will gain knowledge of the full key $x \equiv x_0 + x_1$ at the end of protocol execution, either for a completed swap or for an aborted swap.

\subsubsection{Pre-image non-interactive zero-knowledge proofs of knowledge,}
to prove to the other participant that a valid pre-image $\alpha$ to a given hash $h = \mathcal{H}(\alpha)$ is known and within a specific range, e.g. $\alpha \in [1, l-1]$ where $l$ is related to \texttt{edward25519} curve and $\mathcal{H}$ is \texttt{SHA256}. The scalar $\alpha$ must be serialized in a standard way.

\subsubsection{\texttt{Edward25519} private key non-interactive zero-knowledge proofs of knowledge}
to prove to the other participant that a valid private key $x$ is known for a public key $X$, e.g. signatures are non-interactive zero-knowledge proofs given some public keys.

\subsection{Bitcoin}
Bitcoin requires SegWit activated to be able to chain unbroadcast transactions. This requirements must be fulfilled for any other cryptocurrencies with UTXOs based model that might replace Bitcoin in this swap protocol.

\subsubsection{Timelock,}
to enable new execution paths after some predefined amount of time, e.g. start the refund process after having locked funds on-chain without creating a race condition.

\subsubsection{Hashlock,}
to reveal secrets to the other participant. Hashlocks are primitives that require to reveal some data (a pre-image) associated with a given hash to be allowed to spend the associated UTXO.

\subsubsection{2-out-of-2 multisig,}
to create a common path accessible only by the two participants only if both agreed on it.

\subsection{Curves parameters}
\label{curveParams}
%with \texttt{EdDSA} as describe in CryptoNote whitepaper.
Bitcoin and Monero does not use the same elliptic curves. Bitcoin use \texttt{secp256k1} curve from \textit{Standards for Efficient Cryptography (SEC)} with \texttt{ECDSA} while Monero, based on the second version of CryptoNote, use \texttt{Curve25519}, hereinafter also \texttt{edward25519}, from Daniel J. Bernstein \cite{CerRes10, van2013cryptonote}. We denote curves parameters for

\subsubsection{\texttt{edward25519}} as
\begin{equation}
\begin{split}
    q&: \text{a prime number;}\ a = 2^{255} - 19 \\
    d&: \text{an element of } \mathbb{F}_q;\ d = - 121665/121666 \\
    E&: \text{an elliptic curve equation};\ -x^2 + y^2 = 1 + dx^2y^2 \\
    G&: \text{a base point};\ G = (x, -4/5) \\
    l&: \text{a base point order};\ l = 2^{252} + \scriptsize\text{27742317777372353535851937790883648493} \\
\end{split}
\end{equation}

\subsubsection{\texttt{secp256k1}} as
\begin{equation}
\begin{split}
    p&: \text{a prime number;}\ p = 2^{256} - 2^{32} - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1 \\
    a&: \text{an element of } \mathbb{F}_p;\ a = 0 \\
    b&: \text{an element of } \mathbb{F}_p;\ b = 7 \\
    E'&: \text{an elliptic curve equation};\ y^2 = x^3 + bx + a \\
    G'&: \text{a base point};\ G' = \\ (&\scriptsize\texttt{0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798},\\ &\scriptsize\texttt{0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8}) \\
\end{split}
\end{equation}

\section{Protocol}
In this chapter we describe the protocol to follow for Alice and Bob to swap their funds atomicly and without trusting each other.

The overall protocol is as the following: Alice moves the monero into an address where each participant controls half of the private spend key. The Bitcoin scripting language is then used to reveal one or the other half of the private spend key. Depending on how reveals the shared key, the locked monero change their owner. Bitcoin transactions are designed in such a way that if a participant follows the protocol he can't terminate with a loss.

If the deal goes through, Alice spends the bitcoins by revealing her private key share, thus allowing Bob to spend the locked monero. If the deal is cancelled, Bob spends the bitcoins by revealing his private key share thus allowing Alice to spend the monero, in both cases minus transaction fees.

\begin{figure}[T]
    \begin{table}[H]
      \centering
      {\renewcommand{\arraystretch}{1.2}%
      \begin{tabular}{ | l l l | }
        \hline
          \multicolumn{1}{|c}{Alice (XMR)} &  & \multicolumn{1}{c|}{Bob (BTC)} \\
          & & \\
          $k^v_a, k^s_a \xleftarrow{R} [1, l-1]$ & & $k^v_b, k^s_b \xleftarrow{R} [1, l-1]$ \\
          $K^s_a \leftarrow k^s_aG$ & & $K^s_b \leftarrow k^s_bG$ \\
          $b_a \xleftarrow{R} [1, p-1]$ & & $b_b \xleftarrow{R} [1, p-1]$ \\
          $B_a \leftarrow b_aG'$ & & $B_b \leftarrow b_bG'$ \\
          $h_a \leftarrow \mathcal{H}(k^s_a)$ & & $h_b \leftarrow \mathcal{H}(k^s_b)$ \\
          & & $s \xleftarrow{R} \mathbb{Z}_{2^{256}}$ \\
          & & $h_s \leftarrow \mathcal{H}(s)$ \\
          $z_a \leftarrow \texttt{zkp}(k^s_a)$ & & $z_b \leftarrow \texttt{zkp}(k^s_b)$ \\
           & & \\
          \multicolumn{3}{|c|}{$\xlongleftrightarrow{\langle k^v_a, k^v_b, K^s_a, K^s_b, B_a, B_b, h_a, h_b, h_s, z_a, z_b \rangle}$} \\
          verify $[k^v_b, K^s_b, B_b, z_b]$ & & verify $[k^v_a, K^s_a, B_a, z_a]$ \\
          & $k^v \equiv k^v_a + k^v_b \pmod l$ & \\
          & $K^v = k^vG$ & \\
          & $K^s = K^s_a + K^s_b$ & \\
          & & create $[\text{BTX}_\textit{lock}$, $\text{BTX}_\textit{refund}]$ \\
          & & sign $\text{BTX}_\textit{refund}$ \\
          \multicolumn{3}{|c|}{$\xleftarrow{\langle \text{BTX}_\textit{lock}, \text{BTX}_\textit{refund} \rangle}$} \\
          verify $[\text{BTX}_\textit{lock}$, $\text{BTX}_\textit{refund}]$ & & \\
          sign $\text{BTX}_\textit{refund}$ & & \\
          \multicolumn{3}{|c|}{$\xrightarrow{\langle \text{BTX}_\textit{refund}^\textit{signed} \rangle}$} \\
          & & verify $\text{BTX}_\textit{refund}^\textit{signed}$ \\
          & & sign $\text{BTX}_\textit{lock}$ \\
          & & broadcast $\text{BTX}_\textit{lock}^\textit{signed}$ \\
          \multicolumn{3}{|c|}{$\xleftarrow{(\text{watch BTX}_\textit{lock})}$} \\
          create $\text{XTX}_\textit{lock}$ w/ $(K^v, K^s)$ & & \\
          sign $\text{XTX}_\textit{lock}$ & & \\
          broadcast $\text{XTX}_\textit{lock}^\textit{signed}$ & & \\
          \multicolumn{3}{|c|}{$\xrightarrow{(\text{watch w/ } (k^v, K^s))}$} \\
          & & verify $(K^v, K^s)$ w/ $(k^v, K^s)$ \\
          \multicolumn{3}{|c|}{$\xleftarrow{\langle s \rangle}$} \\
          spend $\text{BTX}_\textit{lock}$ w/ $\langle k^s_a, b_a, s \rangle$ & & \\
          \multicolumn{3}{|c|}{$\xrightarrow{\text{watch BTX}_\textit{lock}}$} \\
          & & $k^s \equiv k^s_a + k^s_b \pmod l$ \\
          & & spend $\text{XTX}_\textit{lock}$ w/ $\langle k^v, k^s \rangle$ \\
        \hline
      \end{tabular}}
    \end{table}
  \caption{Cross-chain atomic swap protocol for Bitcoin--Monero}
  \label{fig:protocol}
\end{figure}

\subsection{Time parameters}
Two timelocks $t_0, t_1$ are defined. $t_0$ defines the time window during it is safe to execute the trade, after $t_0$ the refund process can start, making the trade unsafe to complete because of a race condition (even if hard to exploit in reallity). $t_1$ defines the response time during when Bob needs to react and reveals his private Monero share to get his bitcoins back and allow Alice to redeem her monero (if she locked monero).

\subsection{Monero private keys}
Monero private keys are pairs of \texttt{edward25519} private key. The first key is called view key and the second is called spend key. We use small letters to denote private keys and caps for public keys such that
$$X = xG$$
Where $G$ is the generator element of the cuve (see \ref{curveParams}). We denote
\begin{enumerate}[label=(\roman*)]
    \item the private key $k^v$ as the private view key and $K^v$ as the public view key,
    \item $k^v_a$ as the private view key share of Alice and $k^v_b$ of Bob,
    \item the private key $k^s$ as the private spend key and $K^s$ as the public spend key,
    \item and $k^s_a$ as the private spend key share of Alice and $k^s_b$ of Bob.
\end{enumerate}

\subsubsection{Partial keys}
We denote partial private keys as $k^s_a$ and $k^s_b$ such that
$$k^s_a + k^s_b \equiv k^s \pmod l$$

And then
\begin{equation}
\begin{split}
    k^s_aG &= K^s_a \\
    k^s_bG &= K^s_b \\
    K^s_a + K^s_b = (k^s_a + k^s_b)G = k^sG &= K^s
\end{split}
\end{equation}

The same holds for $k^v$ with $k^v_a$ and $k^v_b$.

\subsection{Zero-Knowledge proofs}
Zero-knowledge proofs are required at the beginning of the protocol for enabling trustlessness. The protocol uses hash as commitements of private keys, but we cannot check the hash of the other participant before it goes on-chain. Thus we need to provide a proof that the hash used in the Bitcoin script is the serialized private share and not other random data.
%Two zero-knowledge proofs are required at the beginning of the protocol for enabling trustlessness. They are quite symmetric but Bob needs to prove an extra piece of information to Alice. We denote Alice's ZKP basic ZKP and Bob's one extended ZKP.

\subsubsection{ZKP}
Alice and Bob must prove to each other with
\begin{equation}
\begin{split}
    k^s &= \text{valid scalar on \texttt{edward25519} curve} \\
    K^s &= k^sG \\
    h &= \mathcal{H}(k^s) \\
\end{split}
\end{equation}

that given $K^s$ and $h$
\begin{equation}
\begin{split}
    \exists k^s \mid K^s = k^sG \land h = \mathcal{H}(k^s) \land k^s \in [1, l-1]
\end{split}
\end{equation}
where $\mathcal{H}(k^s)$ is the hash of the 256-bit little-endian integer representation of $k^s$.

%\subsubsection{Extended ZKP}
%Bob must prove to Alice with
%\begin{equation}
%\begin{split}
%    x_1 &= \text{valid private key on edward25519 curve} \\
%    X_1 &= x_1G \\
%    h_1 &= \mathcal{H}(x) \\
%    s &= \text{random 32 bytes data} \\
%    h_2 &= \mathcal{H}(s)
%\end{split}
%\end{equation}
%
%that given $X_1$, $h_1$ and $h_2$
%\begin{equation}
%\begin{split}
%    \exists x_1, s \mid X_1 = x_1G \land h_1 = \mathcal{H}(x_1) \land h_2 = \mathcal{H}(s) \land x_1, s \in [1, 2^{256}]
%\end{split}
%\end{equation}

\subsection{Bitcoin scripts}

\subsubsection{\texttt{SWAPLOCK}}
is a \texttt{P2SH} used to lock funds and defines the two base execution paths: (1) swap execution and (2) refund execution.

\begin{minted}[escapeinside=||,mathescape=true]{text}
OP_IF
    OP_SHA256 <|$h_a$|> OP_EQUALVERIFY
    OP_SHA256 <|$h_s$|> OP_EQUALVERIFY
    <|$B_a$|> OP_CHECKSIG
OP_ESLE
    <|$t_0$|> OP_CHECKSEQUENCEVERIFY OP_DROP
    2 <|$B_a$|> <|$B_b$|> 2 OP_CHECKMULTISIG
OP_ENDIF
\end{minted}

\subsubsection{Buy \texttt{SWAPLOCK},}
when Alice take control of bitcoins and reveal her Monero shared key allowing Bob to take control of monero. Alice can redeem the \texttt{SWAPLOCK} with:

\begin{minted}[escapeinside=||,mathescape=true]{text}
<|$sig_a$|> <|$s$|> <|$k^s_a$|> OP_TRUE <|\texttt{SWAPLOCK} script|>
\end{minted}

\subsubsection{Refund \texttt{SWAPLOCK},}
is signed by both participants and move the funds into \texttt{REFUND P2SH}. Btx$_2$ use the following redeem script:

\begin{minted}[escapeinside=||,mathescape=true]{text}
OP_0 <|$sig_a$|> <|$sig_b$|> OP_FALSE <|\texttt{SWAPLOCK} script|>
\end{minted}

\subsubsection{\texttt{REFUND}}
is an other \texttt{P2SH} used in case the swap already started on-chain but is cancelled. This refund script is used to lock the only output of a transaction that spends the \texttt{SWAPLOCK} output with the 2-out-of-2 timelocked multisig.

\begin{minted}[escapeinside=||,mathescape=true]{text}
OP_IF
    OP_SHA256 <|$h_b$|> OP_EQUALVERIFY
    <|$B_b$|> OP_CHECKSIG
OP_ESLE
    <|$t_1$|> OP_CHECKSEQUENCEVERIFY OP_DROP
    <|$B_a$|> OP_CHECKSIG
OP_ENDIF
\end{minted}

\subsubsection{Spend \texttt{REFUND},}
when Bob cancels the swap and reveals his Monero private share allowing Alice to regain control over her Monero. Bob can redeem the \texttt{REFUND P2SH} with:

\begin{minted}[escapeinside=||,mathescape=true]{text}
<|$sig_b$|> <|$k^s_b$|> OP_TRUE <|\texttt{REFUND} script|>
\end{minted}

\subsubsection{Claim \texttt{REFUND},}
when Alice take control of bitcoins after the second timelock without revealing her Monero shared key, ending up with Bob loosing money for not following the protocol. Alice can redeem the \texttt{REFUND P2SH} with:

\begin{minted}[escapeinside=||,mathescape=true]{text}
<|$sig_a$|> OP_FALSE <|\texttt{REFUND} script|>
\end{minted}

\subsection{Transactions}
\subsubsection{$\text{BTX}_\textit{lock}$}
is a Bitcoin transaction with $\geq 1$ inputs from Bob and the first output (vout: 0) to \texttt{SWAPLOCK P2SH} and optional change outputs.

\subsubsection{$\text{BTX}_\textit{refund}$}
is a Bitcoin transaction with 1 input consuming \texttt{SWAPLOCK P2SH} ($\text{BTX}_\textit{lock}$, vout: 0) with the 2-out-of-2 timelocked multisig and exaclty one output to \texttt{REFUND P2SH}.

\subsubsection{$\text{XTX}_\textit{lock}$}
is a Monero transaction that sends fund to the address $(K^v,K^s)$.

%\section{Acknowledgement} Loan Ventura, Thomas Roulin and Nicolas Huguenin are acknowledged for their helpful contribution and comments during the completion of this work.

%
% ---- Bibliography ----
%
\printbibliography

\end{document}
